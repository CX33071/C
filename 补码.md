补码是计算机中表示有符号整数的核心编码方式，它解决了原码（符号位 + 数值位）在减法运算中的缺陷

### 一、补码的本质：什么是补码？

补码是一种 “带符号的二进制编码规则”，通过对数值的二进制形式进行特定转换，让负数可以参与加法运算

**核心逻辑**：减去一个数等价于加上这个数的 “补数”（补码）

### 二、补码的编码规则（怎么表示？）

假设用**n 位二进制**表示整数（最高位为符号位：0 表示正数，1 表示负数），编码规则如下：

#### 1. 正数的补码

与原码（二进制本身）完全相同：符号位为 0，数值位为该数的二进制表示。

例：8 位二进制中，+5 的补码：

- 原码：`00000101`（符号位 0，数值位 5 的二进制`0000101`）
- 补码 = 原码：`00000101`

#### 2. 负数的补码

通过 “原码取反 + 1” 得到（符号位参与取反，最终结果符号位为 1）：

#### 3. 特殊值：0 的补码

原码中存在 “+0”（`00000000`）和 “-0”（`10000000`）两种表示，补码中统一为`00000000`（-0 的补码计算后与 + 0 一致），消除了歧义。

#### 4. 表示范围

n 位补码能表示的整数范围是：`[-2ⁿ⁻¹, 2ⁿ⁻¹ - 1]`

- 比原码 / 反码多表示一个负数（`-2ⁿ⁻¹`），这是补码的特殊规定（无需按 “取反 + 1” 计算）。

  

  例：8 位补码范围：

  ```
  -128 ~ +127
  ```

  （

  ```
  -128
  ```

  的补码固定为

  ```
  10000000
  ```

  ）。

### 三、补码的用法：如何用补码做运算？

补码的核心价值是**将减法转化为加法**，运算规则：

- 无论正数还是负数，直接用补码进行加法运算，结果仍是补码；
- 若结果超出 n 位，直接截断高位（只保留 n 位），不影响正确性。

#### 示例 1：计算 5 - 3（即 5 + (-3)）

用 8 位补码计算：

① +5 的补码：`00000101`；

② -3 的补码：

- 绝对值 3 的原码：`00000011` → 取反：`11111100` → 加 1：`11111101`；

  

  ③ 补码相加：

  ```
  00000101 + 11111101 = 100000010
  ```

  （9 位）；

  

  ④ 截断高位（保留 8 位）：

  ```
  00000010
  ```

  （补码），对应十进制 + 2，结果正确。

#### 示例 2：计算 3 - 5（即 3 + (-5)）

① +3 的补码：`00000011`；

② -5 的补码：`11111011`（前面已求）；③ 相加：`00000011 + 11111011 = 11111110`（8 位补码）；

④ 转换为十进制：补码`11111110`是负数，求其绝对值：

- 减 1 得反码：`11111101` → 取反得原码：`00000010`（即 2），故结果为 - 2，正确。

### 五、补码在哪里用？（应用场景）

补码是计算机处理有符号整数的**唯一标准**，所有涉及整数存储和运算的场景都依赖补码：

1. **CPU 寄存器**：存储有符号整数时，寄存器中的二进制是补码形式。
2. **内存**：变量（如 C 语言的`int`、`short`）在内存中以补码存储。
3. **运算器（ALU）**：CPU 的算术逻辑单元执行加减运算时，实际处理的是补码。
4. **编程语言**：高级语言（如 C、Java）中，有符号整数的底层表示和运算均基于补码（开发者无需直接操作，但结果由补码决定）。

### 总结

补码是计算机为解决 “有符号整数运算” 而设计的编码方案，通过 “负数 = 补码”  的规则，将减法转化为加法，简化了硬件并保证了运算正确性。它是现代计算机的基础，所有涉及有符号整数的存储和运算（从 CPU  到编程语言）都依赖补码实现。理解补码，就能理解计算机如何 “思考” 整数运算。